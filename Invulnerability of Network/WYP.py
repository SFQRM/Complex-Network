# @author: SFQRM
# first edit date: 2019-10-21
# function:
#     复现论文

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
import math


# 从文件@filename中读取网络的adjacentMatrix，通过networkx的add_edges方法向对象G中添加边
def readNetwork(filename, N):
    fin = open(filename, 'r')                               # 读文件
    A_matrix = np.zeros((N, N), dtype=int)                  # 创建一个NxN的全零矩阵，数据类型为int型
    matrix_row = 0                                          # 定义矩阵的行，从第0行开始
    for line in fin.readlines():                            # 一次性读取所有行，并存储为字符串列表
        list = line.strip('\n').split(' ')                  # 处理逐行数据：strip表示把头尾的'\n'去掉，split表示以空格来分割行数据，
        # list = line.strip('\n').split('\t')
        A_matrix[matrix_row] = list[0:N]                    # list[0:8]表示列表的0~7列数据放到矩阵中的matrix_row行
        matrix_row += 1

    # print(martrix)
    rowCount = 1                                            # 行数初始化
    colCount = 1                                            # 列数初始化
    for line in A_matrix:
        for node in line:
            if node == 1:
                G.add_edge(rowCount, colCount)              # 节点间连一条边
            colCount += 1
        colCount = 1
        rowCount += 1

    # print(G.edges())
    return A_matrix


# 传入邻接矩阵计算连接概率矩阵
def getProbability(matrix, N):
    D_array = np.array(np.sum(matrix, axis=0))              # D_array: 由各个节点的度数组成的数组
    P_matrix = np.zeros((N, N), dtype=float)                # 创建一个NxN的全零矩阵，数据类型为float型
    for i in range(N):
        for j in range(N):
            if matrix[i, j] == 1:
                P_matrix[i, j] = 1/D_array[i]               # 计算发送概率矩阵

    return P_matrix


# 求矩阵的行列式
def getDeterminant(matrix):
    det = np.linalg.det(matrix)
    return det


def normalization(w):
    sum = 0
    n = w.shape[0]
    for i in range(n):
        sum = sum + w[i]
    mean = sum/n
    for i in range(n):
        sum = math.pow(w[i] - mean, 2)
    s = math.sqrt(sum/(n-1))
    for i in range(n):
        w[i] = (w[i]-mean)/s
    return w


if __name__ == '__main__':
    G = nx.Graph()                                           # G: 定义一个空的图结构
    dirPath = 'data/bridge node network.data'                # dirPath: 数据文件路径
    N = 8                                                    # N: 邻接矩阵的维度
    count = 10                                                # count: 迭代次数
    A_matrix = readNetwork(dirPath, N)                       # 从外部文件读取邻接矩阵
    p_matrix = getProbability(A_matrix, N)                   # p: 发送概率矩阵
    w_vector = np.array(np.sum(A_matrix, axis=0))
    w_vector = w_vector.reshape(-1, 1)                       # w: 将行向量变为列向量

    e = np.zeros((N, N), dtype=float)                        # e: 误差
    W = np.array(np.sum(A_matrix, axis=0))                   # W: 网络中全部节点的权重值组成的列向量
    W = W.reshape(-1, 1)
    p_hat = np.zeros((N, N), dtype=float)                    #

    for k in range(count):
        # w_vector = np.dot(p_matrix, w_vector)
        w_hat = np.dot(p_matrix, w_vector)                   
        for i in range(N):
            for j in range(N):
                # e[j, i] = p_matrix[i, j] * w_vector[i]
                e[j, i] = p_matrix[i, j] * w_hat[i]
                for t in range(N):
                    # e[j, i] = e[j, i] + A_matrix[i, t] * p_matrix[t, j] * w_vector[t]
                    e[j, i] = e[j, i] + A_matrix[i, t] * p_matrix[t, j] * w_hat[t]
        for i in range(N):
            # denominator = np.dot(A_matrix[i], (np.subtract(w_vector, e[:, i].reshape(-1, 1)))) + 0.1
            denominator = np.dot(A_matrix[i], (np.subtract(w_hat, e[:, i].reshape(-1, 1))))
            for j in range(N):
                # np.set_printoptions(precision=4)
                # p_matrix[i, j] = A_matrix[i,j]*(w_vector[j]-e[j,i])/denominator
                p_hat[i, j] = A_matrix[i, j] * (w_hat[j] - e[j, i]) / denominator

        p_matrix = p_hat
        w_vector = w_hat

    print(w_vector)
    w_vector = normalization(w_vector)
    print(w_vector)
